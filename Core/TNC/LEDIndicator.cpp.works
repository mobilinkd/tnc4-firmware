// Copyright 2017 Rob Riggs <rob@mobilinkd.com>
// All rights reserved.

#include "LEDIndicator.h"

#include <stm32l4xx_hal.h>
#include <stm32l4xx_hal_tim.h>
#include <stm32l4xx_hal_tim_ex.h>

#include <functional>

#include <stdint.h>

extern "C" void _Error_Handler(char *, int);

extern TIM_HandleTypeDef htim3;
extern TIM_HandleTypeDef htim16;

namespace mobilinkd { namespace tnc {

}} // mobilinkd::tnc

volatile int32_t bt_pulse = 7500;
volatile int32_t dcd_pulse = 7500;

/**
 * No connection shows a low, slow breathing. Each breath inhale takes
 * for 500ms, is held for 500ms, and exhaled in 500ms. This is repeated
 * every 10 seconds.  Maximum brightness is 20%.
 *
 * Each interrupt occurs at 10ms intervals.
 *
 * The sequence is:
 *  - ramp up 300ms(30)
 *  - hold 400ms (40)
 *  - ramp down 300ms (30)
 *  - wait 9000ms (900)
 *
 *
 */
struct NoConnection {
  enum STATE {
    RAMP_UP_1, WAIT_1, RAMP_DN_1, WAIT_2
  };

  int count{0};
  int state{RAMP_UP_1};

  int operator()()
  {
    int result;
    switch (state) {
    case RAMP_UP_1:
      result = count * 40;
      if (count == 49) {
        count = 0;
        state = WAIT_1;
      } else {
        ++count;
      }
      break;
    case WAIT_1:
      result = 2000;
      if (count ==49) {
        state = RAMP_DN_1;
        count = 49;
      } else {
        ++count;
      }
      break;
    case RAMP_DN_1:
      result = count * 40;
      if (count == 0) {
        count = 0;
        state = WAIT_2;
      } else {
        --count;
      }
      break;
    case WAIT_2:
      result = 0;
      if (count == 849) {
        state = RAMP_UP_1;
        count = 0;
      } else {
        ++count;
      }
      break;
    }
    return result;
  }
};

/**
 * Bluetooth connection shows a double blip. Each blip lasts for 200ms
 * and is separated by 200ms, and is repeated ever 5 seconds.
 *
 * Each interrupt occurs at 10ms intervals.
 *
 * The sequence is:
 *  - ramp up 100s(10)
 *  - ramp down 100ms (10)
 *  - wait 200ms (20)
 *  - ramp up 100ms (10)
 *  - ramp down 100ms (10)
 *  - wait 4400ms (440)
 *
 *
 */
struct BluetoothConnection {
  enum STATE {
    RAMP_UP_1, RAMP_DN_1, WAIT_1, RAMP_UP_2, RAMP_DN_2, WAIT_2
  };

  int count{0};
  int pulse{0};
  int state{RAMP_UP_1};
  int ramp[10] = {1564,3090,4540,5878,7071,8090,8910,9510,9877,9999};

  int operator()()
  {
    int result;
    switch (state) {
    case RAMP_UP_1:
      result = ramp[count] / 2;
      if (count == 9) {
        state = RAMP_DN_1;
      } else {
        ++count;
      }
      break;
    case RAMP_DN_1:
      result = ramp[count] / 2;
      if (count == 0) {
        state = WAIT_1;
      } else {
        --count;
      }
      break;
    case WAIT_1:
      result = 0;
      if (count == 19) {
        state = RAMP_UP_2;
        count = 0;
      } else {
        ++count;
      }
      break;
    case RAMP_UP_2:
      result = ramp[count] / 2;
      if (count == 9) {
        state = RAMP_DN_2;
      } else {
        ++count;
      }
      break;
    case RAMP_DN_2:
      result = ramp[count] / 2;
      if (count == 0) {
        state = WAIT_2;
      } else {
        --count;
      }
      break;
    case WAIT_2:
      result = 0;
      if (count == 439) {
        state = RAMP_UP_1;
        count = 0;
      } else {
        ++count;
      }
      break;
    }
    return result;
  }
};

/**
 * USB connection shows a triple blip. Each blip lasts for 200ms. The
 * first two are separated by 400ms.  The third comes 200ms later.  This
 * is repeated ever 5 seconds.
 *
 * Each interrupt occurs at 10ms intervals.
 *
 * The sequence is:
 *  - ramp up 100s(10)
 *  - ramp down 100ms (10)
 *  - wait 200ms (20)
 *  - ramp up 100s(10)
 *  - ramp down 100ms (10)
 *  - wait 400ms (20)
 *  - ramp up 100ms (10)
 *  - ramp down 100ms (10)
 *  - wait 3800ms (440)
 *
 *
 */
struct USBConnection {
  enum STATE {
    RAMP_UP_1, RAMP_DN_1, WAIT_1, RAMP_UP_2, RAMP_DN_2, WAIT_2, RAMP_UP_3, RAMP_DN_3, WAIT_3
  };

  int count{0};
  int pulse{0};
  int state{RAMP_UP_1};
  int ramp[10] = {1564,3090,4540,5878,7071,8090,8910,9510,9877,9999};

  int operator()()
  {
    int result;
    switch (state) {
    case RAMP_UP_1:
      result = ramp[count];
      if (count == 9) {
        state = RAMP_DN_1;
      } else {
        ++count;
      }
      break;
    case RAMP_DN_1:
      result = ramp[count];
      if (count == 0) {
        state = WAIT_1;
      } else {
        --count;
      }
      break;
    case WAIT_1:
      result = 0;
      if (count == 39) {
        state = RAMP_UP_2;
        count = 0;
      } else {
        ++count;
      }
      break;
    case RAMP_UP_2:
      result = ramp[count];
      if (count == 9) {
        state = RAMP_DN_2;
      } else {
        ++count;
      }
      break;
    case RAMP_DN_2:
      result = ramp[count];
      if (count == 0) {
        state = WAIT_2;
      } else {
        --count;
      }
      break;
    case WAIT_2:
      result = 0;
      if (count == 19) {
        state = RAMP_UP_3;
        count = 0;
      } else {
        ++count;
      }
      break;
    case RAMP_UP_3:
      result = ramp[count];
      if (count == 9) {
        state = RAMP_DN_3;
      } else {
        ++count;
      }
      break;
    case RAMP_DN_3:
      result = ramp[count];
      if (count == 0) {
        state = WAIT_3;
      } else {
        --count;
      }
      break;
    case WAIT_3:
      result = 0;
      if (count == 379) {
        state = RAMP_UP_1;
        count = 0;
      } else {
        ++count;
      }
      break;
    }
    return result;
  }
};

/**
 * USB connection shows a triple blip. Each blip lasts for 200ms. The
 * first two are separated by 400ms.  The third comes 200ms later.  This
 * is repeated ever 5 seconds.
 *
 * Each interrupt occurs at 10ms intervals.
 *
 * The sequence is:
 *  - ramp up 100s(10)
 *  - ramp down 100ms (10)
 *  - wait 200ms (20)
 *  - ramp up 100s(10)
 *  - ramp down 100ms (10)
 *  - wait 400ms (20)
 *  - ramp up 100ms (10)
 *  - ramp down 100ms (10)
 *  - wait 3800ms (440)
 *
 *
 */
struct Flash {
  enum STATE {
    RAMP_UP, ON, RAMP_DN, OFF
  };

  int count{0};
  int pulse{0};
  int state{RAMP_UP};
  int ramp[10] = {1564,3090,4540,5878,7071,8090,8910,9510,9877,9999};

  int green()
  {
    int result;
    switch (state) {
    case RAMP_UP:
      result = ramp[count];
      if (count == 9) {
        state = ON;
      } else {
        ++count;
      }
      break;
    case ON:
      result = ramp[count];
      break;
    case RAMP_DN:
      result = ramp[count];
      if (count == 0) {
        state = OFF;
      } else {
        --count;
      }
      break;
    case OFF:
      result = 0;
      break;
    }
    return result;
  }
};

std::function<int(void)> blinker = NoConnection();


void HTIM3_PeriodElapsedCallback()
{
  htim3.Instance->CCR2 = dcd_pulse;
  dcd_pulse = (dcd_pulse * 98) / 100;
  if (dcd_pulse == 0){
    HAL_TIM_Base_Stop_IT(&htim3);
    HAL_TIM_PWM_Stop(&htim3, TIM_CHANNEL_2);
  }
}

void HTIM16_PeriodElapsedCallback()
{
  htim16.Instance->CCR1 = blinker();
}

#if 0
void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef* htim)
{
  if (htim->Instance == TIM16) {
    TIM_OC_InitTypeDef sConfigOC;

    sConfigOC.OCMode = TIM_OCMODE_PWM1;
    sConfigOC.Pulse = pulse;
    sConfigOC.OCPolarity = TIM_OCPOLARITY_LOW;
    sConfigOC.OCNPolarity = TIM_OCNPOLARITY_LOW;
    sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
    sConfigOC.OCIdleState = TIM_OCIDLESTATE_SET;
    sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_SET;
    if (HAL_TIM_PWM_ConfigChannel(&htim16, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
    {
      _Error_Handler(__FILE__, __LINE__);
    }

    pulse = (pulse * 8) / 10;

    if (pulse == 0) HAL_TIM_Base_Stop_IT(&htim16);

  }
}
#endif

void indicate_turning_on(void)
{
  HAL_TIM_Base_Start_IT(&htim3);
  HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_2);
  HAL_Delay(200);

  HAL_TIM_Base_Start_IT(&htim16);
  HAL_TIMEx_PWMN_Start(&htim16, TIM_CHANNEL_1);
}

void indicate_waiting_to_connect(void)
{
  blinker = NoConnection();
}
void indicate_connected_via_usb(void)
{
  blinker = USBConnection();
}
void indicate_connected_via_ble(void)
{
  blinker = BluetoothConnection();
}

void indicate_tx(void)
{

}

// DCD is active.
void rx_on()
{

}

// DCD is active.
void rx_off()
{

}



constexpr int32_t TIMER_PRESCALER=749; // 64000 counts
