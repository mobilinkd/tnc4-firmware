// Copyright 2020 Rob Riggs <rob@mobilinkd.com>
// All rights reserved.

#include "M17Demodulator.h"
#include "AudioLevel.hpp"

#include "main.h"

#include "stm32l4xx_hal.h"

#include <array>
#include <cstdint>

namespace mobilinkd { namespace tnc {

constexpr size_t MAX_MISSING_SYNC = 5;

m17::Indicator lsf_indicator{GPIOB, GPIO_PIN_0};
m17::Indicator pre_indicator{GPIOA, GPIO_PIN_7};
m17::Indicator str_indicator{GPIOA, GPIO_PIN_6};

void M17Demodulator::start()
{
    SysClock72();

//    m17::preamble_sync.set_indicator(&pre_indicator);
//    m17::lsf_sync.set_indicator(&lsf_indicator);
//    m17::stream_sync.set_indicator(&str_indicator);

    demod_filter.init(m17::rrc_taps_f15.data());
    passall(kiss::settings().options & KISS_OPTION_PASSALL);
    audio::virtual_ground = (VREF + 1) / 2;

    hadc1.Init.OversamplingMode = DISABLE;
    if (HAL_ADC_Init(&hadc1) != HAL_OK)
    {
        CxxErrorHandler();
    }

    ADC_ChannelConfTypeDef sConfig;

    sConfig.Channel = AUDIO_IN;
    sConfig.Rank = ADC_REGULAR_RANK_1;
    sConfig.SingleDiff = ADC_SINGLE_ENDED;
    sConfig.SamplingTime = ADC_SAMPLETIME_92CYCLES_5;
    sConfig.OffsetNumber = ADC_OFFSET_NONE;
    sConfig.Offset = 0;
    if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
        CxxErrorHandler();

    startADC(2499, ADC_BLOCK_SIZE);
//    getModulator().start_loopback();

    locked_ = false;
}

constexpr int8_t SAMPLES_PER_SYNC_WORD = 80;

void M17Demodulator::update_values(uint8_t index, bool update_fd, bool quiet)
{
	auto [estimated_index, locked] = cr(index);

	// Apply the filtered index when locked, otherwise apply
	// the raw index.  This helps converge a new signal and
	// improves noise immunity after lock.
	if (update_fd)
	{
		if (locked) m17::correlator.apply(fd, estimated_index);
		else m17::correlator.apply(fd, index);
	}

	estimated_frequency_offset = fd.frequency_estimate;
	estimated_deviation = fd.deviation_estimate;
	if (!quiet) {
		INFO("%lu: jitter = %d, %d", osKernelGetTickCount(), int(cr.jitter * 1000), locked);
	}
	sample_index = estimated_index;
	locked_ = locked;
}

hdlc::IoFrame* M17Demodulator::operator()(const q15_t* input)
{
	str_indicator.on();

    hdlc::IoFrame* frame_result = nullptr;
    float evma = 0.f;
    bool locked = false;

    auto filtered = demod_filter(input, 1.f / 2560.f);
//    getModulator().loopback(filtered);

    uint8_t pre_index;
    uint8_t lsf_index;
    uint8_t str_index;
    uint8_t pkt_index = 0;

    bool pre_updated = false;
    bool lsf_updated = false;
    bool str_updated = false;
    bool pkt_updated = false;

    if (!locked_) d_state = DemodState::UNLOCKED;

    for (size_t i = 0; i != ADC_BLOCK_SIZE; ++i)
    {
        auto filtered_sample = m17::correlator(filtered[i]);

        switch (d_state)
        {
        case DemodState::UNLOCKED:
        	missing_sync_count = MAX_MISSING_SYNC;
            if (!locked_)
            {
            	pre_indicator.off();
    			pre_index = m17::preamble_sync(m17::correlator);
    			pre_updated = m17::preamble_sync.updated();
    			if (pre_updated)
    			{
    				update_values(pre_index, true, true);
    				ITM_SendChar('.');
//					INFO("p sync %d, %d",
//						int((1.0 / estimated_deviation) * 1000),
//						int(estimated_frequency_offset * 1000));
    				if (locked_)
    				{
    					d_state = DemodState::LSF_SYNC;
    					INFO("p sync %d, %d",
    						int((1.0 / estimated_deviation) * 1000),
    						int(estimated_frequency_offset * 1000));
    					pre_indicator.on();
    					sync_count = 0;
    				}
    				break;
    			}
            }
			lsf_index = m17::lsf_sync(m17::correlator);
			lsf_updated = m17::lsf_sync.updated();
			if (lsf_updated)
			{
				update_values(lsf_index, false, true);
				ITM_SendChar(':');
				if (locked_)
				{
					d_state = DemodState::FRAME;
					sync_word_type = M17FrameDecoder::SyncWordType::LSF;
					INFO("l sync");
				}
				break;
			}
			str_index = m17::stream_sync(m17::correlator);
			str_updated = m17::stream_sync.updated();
			if (str_updated)
			{
				update_values(str_index, false, true);
				ITM_SendChar('+');
				if (locked_)
				{
					d_state = DemodState::FRAME;
					sync_word_type = M17FrameDecoder::SyncWordType::STREAM;
					INFO("s sync");
				}
				break;
			}
			break;
        case DemodState::LSF_SYNC:
        	lsf_indicator.on();
			lsf_index = m17::lsf_sync(m17::correlator);
			lsf_updated = m17::lsf_sync.updated();
            if (lsf_updated)
            {
            	update_values(lsf_index);
            	d_state = DemodState::FRAME;
            	sync_word_type = M17FrameDecoder::SyncWordType::LSF;
            	INFO("l sync");
            	break;
            }
			str_index = m17::stream_sync(m17::correlator);
			str_updated = m17::stream_sync.updated();
            if (str_updated)
            {
            	update_values(str_index);
				sync_word_type = M17FrameDecoder::SyncWordType::STREAM;
				d_state = DemodState::FRAME;
				INFO("s sync");
				break;
            }
			pre_index = m17::preamble_sync(m17::correlator);
			pre_updated = m17::preamble_sync.updated();
			if (pre_updated)
			{
				update_values(pre_index, true, true);
				ITM_SendChar('.');
				break;
			}
            if (sync_count++ > 1920)
            {
            	d_state = DemodState::UNLOCKED;
            	cr.unlock();
            }
            break;
        case DemodState::STREAM_SYNC:
        	lsf_indicator.on();
			str_index = m17::stream_sync(m17::correlator);
			str_updated = m17::stream_sync.updated();
			sync_count += 1;
            if (sync_count > 70 && str_updated)
            {
            	update_values(str_index);
				sync_word_type = M17FrameDecoder::SyncWordType::STREAM;
				d_state = DemodState::FRAME;
				INFO("s sync");
            }
            else if (sync_count > 98)
            {
            	missing_sync_count += 1;
            	if (missing_sync_count < MAX_MISSING_SYNC)
            	{
					sync_word_type = M17FrameDecoder::SyncWordType::STREAM;
					d_state = DemodState::FRAME;
					INFO("s unsync");
            	}
            	else
            	{
					d_state = DemodState::UNLOCKED;
	            	cr.unlock();
					INFO("s unlock");
					locked_ = false;

            	}
            }
            break;
        case DemodState::PACKET_SYNC:
			pkt_index = m17::packet_sync(m17::correlator);
			pkt_updated = m17::packet_sync.updated();
			sync_count += 1;
			if (sync_count > 70 && pkt_updated)
			{
				update_values(pkt_index);
				sync_word_type = M17FrameDecoder::SyncWordType::PACKET;
				d_state = DemodState::FRAME;
				INFO("k sync");
				break;
			}
			else if (sync_count > 98)
			{
				missing_sync_count += 1;
            	if (missing_sync_count < MAX_MISSING_SYNC)
            	{
					sync_word_type = M17FrameDecoder::SyncWordType::PACKET;
					d_state = DemodState::FRAME;
					INFO("k unsync");
            	}
            	else
            	{
					d_state = DemodState::UNLOCKED;
	            	cr.unlock();
					INFO("k unlock");
					locked_ = false;

            	}
			}
			break;
        case DemodState::FRAME:
        	lsf_indicator.off();
			if (m17::correlator.index() == sample_index)
			{
				auto demod_result = new_demod(filtered_sample);
				auto [sample, phase, symbol, evm] = demod_result;
				std::tie(locked, evma) = dcd(evm);

				// We need to use raw filtered samples when updating frequency
				// and deviation estimates.
				if (locked_ && (symbol == -3 or symbol == +3))
					fd(filtered_sample);

				auto n = llr<float, 4>(sample);
				int8_t* tmp;
				auto len = framer(n, &tmp);
				if (len != 0)
				{
					std::copy(tmp, tmp + len, buffer.begin());
					auto valid = decoder(sync_word_type, buffer, frame_result, ber);
					INFO("stream: %d, dt: %5d, evma: %5d, dev: %5d, freq: %5d, locked: %d, ber: %d",
						int(demodState), int(dt * 10000),
						int(evma * 1000), int((1.0 / estimated_deviation) * 1000),
						int(estimated_frequency_offset * 1000),
						locked_, ber);

					switch (decoder.state())
					{
					case M17FrameDecoder::State::STREAM:
					case M17FrameDecoder::State::LSF:
						d_state = DemodState::STREAM_SYNC;
						// INFO("DemodState::STREAM_SYNC");
						break;
					default:
						d_state = DemodState::PACKET_SYNC;
						// INFO("DemodState::PACKET_SYNC");
						break;
					}

					sync_count = 0;

					switch (valid)
					{
					case M17FrameDecoder::DecodeResult::FAIL:
						WARN("decode invalid");
						if (frame_result && !passall_)
						{
						   if (frame_result) hdlc::release(frame_result);
						   frame_result = nullptr;
						}
						break;
					case M17FrameDecoder::DecodeResult::EOS:
						demodState = DemodState::UNLOCKED;
		            	cr.unlock();
						break;
					case M17FrameDecoder::DecodeResult::OK:
						// INFO("valid frame for sw %d", int(sync_word_type));
						if (ber < 40) missing_sync_count = 0;
						break;
					case M17FrameDecoder::DecodeResult::INCOMPLETE:
						// INFO("lich frame for sw %d", int(sync_word_type));
						missing_sync_count = 0;
						break;
					}
				}
				if (!locked_) d_state = DemodState::UNLOCKED;
			}
			break;
        }
    }
    str_indicator.off();

    return frame_result;
}

M17Demodulator::demod_result_t M17Demodulator::new_demod(float sample)
{
	sample -= estimated_frequency_offset;
	sample *= estimated_deviation;
    auto [symbol, evm] = symbol_evm(sample);
    evm_average = symbol_evm.evm();
    float polarity = kiss::settings().rx_rev_polarity() ? -1.f : 1.f;

    return std::make_tuple(sample, 0.f, symbol * polarity, evm);
}

}} // mobilinkd::tnc
