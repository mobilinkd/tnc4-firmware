// Copyright 2021 Rob Riggs <rob@mobilinkd.com>
// All rights reserved.

#pragma once

#include "IirFilter.hpp"

#include <algorithm>
#include <array>
#include <cstdlib>

namespace mobilinkd { namespace m17 {

// 1/16
constexpr std::array<float, 3> loop_b = { 0.00844269,  0.01688539,  0.00844269 };
constexpr std::array<float, 3> loop_a = { 1.        , -1.72377617,  0.75754694 };

// 1/32
constexpr std::array<float, 3> lock_b = { 0.00225158, 0.00450317, 0.00225158 };
constexpr std::array<float, 3> lock_a = { 1.        , -1.86136115,  0.87036748 };

// 1/64 4-pole
//constexpr std::array<float, 5> lock_b = { 3.40605298e-07, 1.36242119e-06, 2.04363179e-06,
//		1.36242119e-06, 3.40605298e-07 };
//constexpr std::array<float, 5> lock_a = { 1.        , -3.87173472,  5.62336619, -3.63122726,
//		0.87960124 };

// 1/4
//constexpr std::array<float,3> pll_b = {0.09763107,  0.19526215,  0.09763107};
//constexpr std::array<float,3> pll_a = {1.        , -0.94280904,  0.33333333};

struct ClockRecovery
{
	tnc::IirFilter<3> lock_filter{lock_b, lock_a};
	tnc::IirFilter<3> loop_filter{loop_b, loop_a};

	float filtered_index;
	float jitter;
	float lock_level;
	float unlock_level;
	bool locked = false;
	const int8_t sps;
	const int8_t max_delta;
	int8_t last_index;

	ClockRecovery(float lock, float unlock, int8_t sps = 10)
	: lock_level(lock), unlock_level(unlock), sps(sps), max_delta(sps / 2), last_index(max_delta)
	{
		for (size_t i = 0; i != 10; ++i) lock_filter(1.f);
	}

	void unlock() { locked = false; }

	bool is_locked()
	{
		if (locked && jitter > unlock_level)
		{
			locked = false;
		}
		else if (!locked && jitter < lock_level)
		{
			locked = true;
		}
		return locked;
	}

	int8_t timing_delta(int8_t timing_index)
	{
		auto delta = timing_index - last_index;
		if (delta > max_delta)
		{
			delta -= sps;
		}
		else if (delta < -max_delta)
		{
			delta += sps;
		}
		last_index = timing_index;
		return delta;
	}

	auto operator()(int8_t timing_index)
	{
		// This is complicated because the timing index has a discontinuity.
		// The only way around this is to normalize the index in some manner.
		// The best way to do this is to track the difference from one
		// estimate to the next, so we measure the delta.

		auto delta = timing_delta(timing_index);
		auto filtered_delta = loop_filter(delta);
		filtered_index = filtered_delta + timing_index;
		jitter = lock_filter(std::abs(delta));
		int8_t estimated_index = std::roundf(filtered_index);
		if (estimated_index < 0) estimated_index += sps;
		else if (estimated_index >= sps) estimated_index -= sps;
		return std::make_tuple(estimated_index, is_locked());
	}
};

}} // mobilinkd::m17
